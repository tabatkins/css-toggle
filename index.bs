<pre class='metadata'>
Title: CSS Toggles
Group: CSSWG
Status: UD
Work Status: exploring
ED: http://tabatkins.github.io/css-toggle/
Shortname: css-toggle
Level: 1
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact
Editor: Miriam E. Suzanne, Invited Expert, http://miriamsuzanne.com/contact
Abstract: This specification defines a way to associate a "toggleable value" with an element which can be used in Selectors to select an element, and declarative ways to set and modify this value on the element.
Ignored Terms: spoiler-text, content-visibility
</pre>

<pre class=link-defaults>
spec:css-display-3; type:dfn; text:element
spec:css-contain-2; type:property; text:content-visiblity
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
    margin: 1em 0;
}
</style>

<h2 id="introduction">
Introduction</h2>

	<em>This section is not normative.</em>

	Many user-interface languages define elements which can have "toggleable state",
	which can be modified by user interaction
	and responded to by the element.
	For example, in HTML, the <code>&lt;input type=checkbox></code> has a "checked" state
	which toggles between true and false when the user activates the element,
	and which is selected by the '':checked'' pseudoclass.

	These sorts of elements are extremely useful,
	to the point that authors sometimes abuse them
	to get the same functionality on <em>other</em> elements:

	<div class='example'>
		The following markup example shows how to lightly abuse HTML semantics
		to declaratively use toggleable state:

		<xmp highlight=markup>
			<ul class='ingredients'>
			  <li><label><input type=checkbox><span>1 banana</span></label>
			  <li><label><input type=checkbox><span>1 cup blueberries</span></label>
			  ...
			</ul>
			<style>
			input[type='checkbox'] {
			  display: none;
			}
			input[type='checkbox']:checked + span {
			  color: silver;
			  text-decoration: line-through;
			}
			</style>
		</xmp>

		In this markup,
		one can cross out ingredients as they're used in the recipe
		by simply clicking on them,
		without any scripting being involved.
		The <{label}> "transfers" the activation
		to the (hidden) checkboxes,
		which are then used to style the span.
	</div>

	This module generalizes this ability
	and allows it to be applied to any element via CSS,
	so authors do not have to abuse host language semantics for styling purposes.
	It defines a a way of attaching lightweight "state" to an element via CSS
	('toggle-root'),
	defining how user interactions can change that state
	('toggle-trigger'),
	and responding to that state from CSS
	('':toggle()'' pseudo-class).
	Scripting can also create, modify, and respond to this state,
	to accommodate more complicated scenarios.

	It also defines how to infer reasonable accessibility semantics
	from the toggle structure,
	making it simpler and more reliable
	to produce accessible pages
	using these sorts of basic interactivity
	without the author having to manually annotate a page
	with ARIA attributes or similar.

<h3 id="terminology">
Terminology</h3>

	Any element can become a <dfn export>toggle root</dfn>,
	meaning it hosts one or more [=toggles=].
	Each [=toggle=] has a name,
	a value between 0 and some maximum,
	and a few other bits of metadata,
	all of which can be set via the 'toggle-root' property.
	The toggle is visible to the [=toggle root=],
	its descendants,
	and possibly its siblings and their descendants
	(if the toggle says they can);
	any element that can "see" a [=toggle=]
	can use the '':toggle()'' pseudo-class
	to select the element based on the toggle's value.

	Any element that can see a [=toggle=]
	can also <em>trigger</em> the toggle,
	changing its value when the element is "activated",
	via the 'toggle-trigger' property.
	This means you can have elements that self-trigger their own toggle,
	like checkboxes,
	but also have toggles that are visible to wide sections of a page
	and are triggered by buttons (or tabs, or headings, etc)
	inside that section,
	so multiple elements can use '':toggle()'' to respond to the toggle.

	Toggles can also be grouped together,
	so that only one of the toggles in the group
	can have a non-zero value at a time,
	like how radio buttons work in HTML.


<h2 id=toggles>
Toggle Concepts</h2>

	A <dfn for=CSS export>toggle</dfn> is a [=struct=] associated with an [=element=],
	which represents something that can be toggled on or off by user action,
	and matched with Selectors.
	Toggles have the following [=struct/items=]:

	<dl dfn-for="toggle, toggle specifier" export>
		: <dfn>name</dfn>
		:: A <<custom-ident>>.

		: <dfn>value</dfn>
		::
			A <<custom-ident>> or non-negative <<integer>>:
			either 0 (the <dfn>inactive value</dfn>)
			or a value 1 or higher (the <dfn lt="active value">active values</dfn>).


		: <dfn>states</dfn>
		::
			Either an integer greater than or equal to 1,
			indicating the nominally maximum integer [=toggle/value=],
			or a [=/list=] of unique state names,
			each of which are <<custom-ident>>s.

			This also defines the <dfn>maximum state</dfn> of a toggle,
			as either the [=toggle/states=] value (if it's an integer)
			or the length of [=toggle/states=] minus 1 (if it's a list).

			Note: Toggles can be set to integer values larger than than the "maximum",
			or to ident values not given in the list of names,
			but when a toggle is incremented or decremented
			it will treat all such values as out-of-bounds
			and bring the value back within the range defined by [=toggle/states=].

		: <dfn>group</dfn>
		::
			A [=boolean=] indicating whether the [=toggle=] is part of a [=toggle group=]
			(of the same [=toggle/name=])
			or not.

		: <dfn>scope</dfn>
		::
			An enum indicating what sort of [=toggle/scope=] the [=toggle=] uses.
			It can have two values:

			* <dfn>"wide"</dfn>, indicating the toggle has [=toggle/wide scope=]
				(it's visible to the element, its descendants,
				and its following siblings and their descendants).
			* <dfn>"narrow"</dfn>, indicating the toggle has [=toggle/narrow scope=]
				(it's visible to the element and its descendants only).

		: <dfn>overflow</dfn>
		:: An enum
			(either <dfn>"cycle"</dfn>, <dfn>"cycle-on"</dfn> or <dfn>"sticky"</dfn>),
			specifying how to react when a [=toggle activation=]
			would increment the [=toggle/value=]
			above its maximum
			or below its minimum.

			<div class=note>
				The precise details are defined in [=change a toggle=],
				but in short:

				* For ''cycle'',
					incrementing past the maximum
					resets the value to 0,
					and decrementing below 0
					resets it to the maximum.

				* For ''cycle-on'',
					incrementing past the maximum
					resets the value to 1,
					and decrementing it below 1
					resets it to the maximum.

					(In other words,
					the toggle "stays on"
					once it reaches an [=active value=],
					rather than cycling back to an [=inactive value=].)

				* For ''sticky'',
					incrementing past the maximum value
					resets the value to the maximum,
					and decrementing it below 0
					resets it to 0.
			</div>
	</dl>

	[=Toggles=] are persistent state on an element.
	Once created, none of their items are affected by CSS,
	and only their [=toggle/value=] can be changed by user interaction.
	(Scripting can change the other items, however;
	see [[#dom]].)
	An element can have any number of [=toggles=].

	<div algorithm>
		To <dfn>match values</dfn>,
		given |toggle| (a [=toggle=]),
		a test value |test value| (an integer or <<custom-ident>>),
		and optionally |states|
		(a [=toggle/states=] value):

		1. If |states| was not passed,
			let |states| be |toggle|'s own [=toggle/states=] value.

		2. Let |toggle value| be |toggle|'s value.

		3. If |toggle value| and |test value| are both integers,
			and the same integer,
			return true.

		4. If |toggle value| and |test value| are both <<custom-ident>>s,
			and are [=identical to=] each other,
			return true.

		5. If |states| is a list of <<custom-ident>>s,
			and |toggle value| is a <<custom-ident>> in the list,
			set |toggle value| to its index in the list.

			Do the same for |test value| if it is a <<custom-ident>>.

			If |toggle value| and |test value| are now both the same integer,
			return true.

		6. Otherwise, return false.
	</div>

	----

	A <dfn for=toggle export>toggle specifier</dfn> is a [=struct=]
	associated with an element,
	with the same structure as a [=toggle=].
	They serve multiple roles:
	they specify what [=toggles=] the element is expected to have on it
	(creating fresh ones if they don't exist),
	provide default values for the newly-created [=toggle's=] items,
	and override a [=toggle's=] default behavior when it receives a [=toggle activation=].

	[=Toggle specifiers=] are defined by the 'toggle-root' property;
	they are not persistent state on the element.
	An element can have any number of [=toggle specifiers=].

	----

	A <dfn for=CSS export>toggle group</dfn> is a [=struct=] associated with an [=element=],
	which groups together toggles of the same name
	so that only one can be in an [=active value=] at a time.
	[=Toggle groups=] have the following [=struct/items=]:

	<dl dfn-for="toggle group" export>
		: <dfn>name</dfn>
		:: A <<custom-ident>>.

		: <dfn>scope</dfn>
		::
			An enum indicating what sort of [=toggle/scope=] the [=toggle group=] uses.
			It can have two values:

			* <dfn>"wide"</dfn>, indicating the toggle has [=toggle/wide scope=]
				(it's visible to the element, its descendants,
				and its following siblings and their descendants).
			* <dfn>"narrow"</dfn>, indicating the toggle has [=toggle/narrow scope=]
				(it's visible to the element and its descendants only).
	</dl>

	[=Toggle groups=] are defined by the 'toggle-group' property;
	they are not persistent state on an element.
	An element can have any number of [=toggle groups=].

	A [=toggle=] is <dfn for=toggle export>in a toggle group</dfn>
	if its [=toggle/group=] boolean is true;
	if the element is [=in scope=] for a [=toggle group=]
	with the same [=toggle/name=] as the [=toggle=],
	it's in that group;
	otherwise, it's in a document-wide <dfn for=CSS export>implicit toggle group</dfn>
	with the same [=toggle/name=].

	----

	[=Toggles=] and [=toggle groups=] have a scope,
	defining what additional elements
	(beyond the element the [=toggle=]/[=toggle group=] is on)
	can see and interact with the [=toggle=]/[=toggle group=].

	If the [=toggle=] ([=toggle group=]) has <dfn for=toggle export>wide scope</dfn>,
	it's visible to the element it's defined on,
	its descendants
	its [=tree/following=] [=tree/siblings=],
	and their [=tree/descendants=].

	If the [=toggle=] ([=toggle group=]) has <dfn for=toggle export>narrow scope</dfn>,
	it's visible to the element it's defined on
	and its descendants.

	[=Toggles=] of the same [=toggle/name=] "shadow" earlier ones;
	if multiple toggles of a given [=toggle/name=] would have overlapping scopes,
	an element is only <dfn for=toggle export>in scope</dfn>
	for the [=toggle=] created by the nearest [=preceding=] element in [=tree order=].
	The same applies to [=toggle groups=].
	However, [=toggles=] and [=toggle groups=] do not interfere with each other's scopes;
	an element can "see past" a [=toggle=] to find a [=toggle group=] of the same name it's [=in scope=] for,
	and vice versa.


<h3 id="toggle-vs-props">
Toggles and CSS Properties</h3>

	To allow for toggles to be responded to by Selectors
	without causing any circularity issues,
	[=toggles=] themselves are invisible state on an element,
	separate from any CSS properties that might apply.
	The CSS properties merely define which elements can <em>activate</em> a toggle,
	and which elements can <em>respond</em> to a toggle activation
	(and how they do so).

	<div class=example>
		For example, while an element needs 'toggle-root' to establish a toggle,
		once a toggle is created,
		removing the 'toggle-root' property does not affect the toggle.

		<pre class=lang-css>
		.toggleable {
			toggle-root: foo 1;
			toggle-trigger: foo;
		}
		.toggleable:toggle(foo) {
			toggle-root: none;
			toggle-trigger: none;
		}
		</pre>

		In this example, the toggleable element declares that it can establish a ''foo'' toggle,
		and activate it.
		During a rendering update,
		the ''foo'' toggle is created on the element
		(initially with a value of 0, its [=inactive value=]);
		when the element is clicked, it's incremented to its [=active value=] (1).

		At this point, the '':toggle(foo)'' rule begins to match,
		and removes the ''toggle-*'' properties.
		This does not remove the ''foo'' toggle or affect its value, however;
		it still exists and is still set to ''1'',
		so the '':toggle()'' pseudo-class will continue matching.
		However, further activations of the element
		will no longer affect the ''foo'' toggle,
		since 'toggle-trigger' was changed to ''toggle-trigger/none''.

		The ''foo'' toggle is thus "frozen" in the activated state
		(unless the author has other elements in the toggle's [=toggle/scope=] that can also affect it,
		or tweaks the value manually via JS).
	</div>


<!--
████████   ███████   ███████  ████████
██     ██ ██     ██ ██     ██    ██
██     ██ ██     ██ ██     ██    ██
████████  ██     ██ ██     ██    ██
██   ██   ██     ██ ██     ██    ██
██    ██  ██     ██ ██     ██    ██
██     ██  ███████   ███████     ██
-->

<h2 id=toggle-root-property>
Creating a Toggle: the 'toggle-root' property</h2>

	<pre class='propdef'>
	Name: toggle-root
	Value: none | <<toggle-specifier>>#
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: as specified
	Animatable: no
	</pre>

	<pre class=prod>
		<dfn><<toggle-specifier>></dfn> =
			<<custom-ident>>
			[
				<<toggle-states>> [at <<toggle-value>>]? ||
				<<toggle-overflow>> ||
				group ||
				self
			]?
		<dfn><<toggle-states>></dfn> = <<integer [1, ∞]>> | '[' <<custom-ident>>* ']'
		<dfn><<toggle-value>></dfn> = <<integer [0, ∞]>> | <<custom-ident>>
		<dfn><<toggle-overflow>></dfn> = cycle | cycle-on | sticky
	</pre>

	The 'toggle-root' property causes [=toggles=] to be created on an element,
	and controls how the [=toggles=] are updated when they are activated.

	<dl dfn-type=value dfn-for=toggle-root>
		<dt><dfn>none</dfn>
		<dd>
			The element has no [=toggle specifiers=].

			(This does not remove any [=toggles=] that have already been established
			on the element.)

		<dt><dfn><<toggle-specifier>>#</dfn>
		<dd>
			The element has one or more [=toggle specifiers=],
			one per <<toggle-specifier>>,
			which determine how toggles will be initially created
			if they don't already exist on the element,
			and how they react to being activated.

			Each <<toggle-specifier>> is composed of several parts,
			most of which are optional,
			corresponding to the [=struct/items=] of a [=toggle specifier=].
			They specify how the newly-created [=toggle=]
			will be set up:

			* The initial <<custom-ident>>
				specifies the [=toggle specifier/name=].
				The <<custom-ident>> cannot be the keyword <css>none</css>.

			* The <<toggle-states>> specifies the [=toggle specifier/states=].
				If specified as an <<integer>>,
				it sets [=toggle specifier/states=] to the given number;
				if specified as a bracketed list of <<custom-ident>>s,
				it sets [=toggle specifier/states=]
				to a list containing those identifiers.
				If omitted, defaults to ''1''.

				If <<toggle-states>> is a bracketed list,
				and there are any repeated <<custom-ident>>s among its items,
				the property is invalid.

			* The <<toggle-value>>, if specified,
				specifies the initial [=toggle specifier/value=].
				If omitted, it's set to 0.

			* The <<toggle-overflow>> keyword, if specified,
				specifies the [=toggle specifier/overflow=] enum.
				If omitted, it's set to "cycle".

			* The <dfn>group</dfn> keyword, if specified,
				sets the [=toggle specifier/group=] boolean to true.
				If omitted, it's set to false.

			* The <dfn>self</dfn> keyword, if specified,
				sets the [=toggle specifier/scope=] enum to "narrow".
				If omitted, it's set to "wide".

			In addition to specifying how to create new [=toggles=],
			a [=toggle specifier=] overrides the existing [=toggle's=]
			[=toggle/states=],
			[=toggle/overflow=],
			and [=toggle/group=],
			if they differ,
			allowing an existing [=toggle=] to have its behavior changed
			if necessary.
	</dl>

	<div class='example'>
		Revisiting the example in the Introduction,
		the same ingredient list can be specified in simple HTML and CSS:

		<xmp class=lang-html>
			<ul class='ingredients'>
			 	<li>1 banana
			 	<li>1 cup blueberries
				...
			</ul>
			<style>
			li {
				toggle: check self;
			}
			li:toggle(check) {
				color: silver;
				text-decoration: line-through;
			}
			</style>
		</xmp>

		The effect is identical to what was specified in the Introduction example,
		except the markup is much simpler and more semantic.
	</div>

<h3 id='toggle-creation'>
Toggle Creation Details</h3>

	Each [=element=] has a list of <dfn export for=element>established toggles</dfn>,
	representing [=toggles=] on the element.
	These are created automatically by the 'toggle-root' property,
	and/or manually by interacting with the {{Element/toggles|Element.toggles}} map.

	Issue: Define the precise point in [=update the rendering=]
	when toggles are created
	if 'toggle-root' names a toggle that doesn't exist on the element yet.


<!--
 ██████   ████████   ███████  ██     ██ ████████
██    ██  ██     ██ ██     ██ ██     ██ ██     ██
██        ██     ██ ██     ██ ██     ██ ██     ██
██   ████ ████████  ██     ██ ██     ██ ████████
██    ██  ██   ██   ██     ██ ██     ██ ██
██    ██  ██    ██  ██     ██ ██     ██ ██
 ██████   ██     ██  ███████   ███████  ██
-->

<h3 id=toggle-group-property>
Linking Toggle Values: the 'toggle-group' property</h3>

	<pre class='propdef'>
	Name: toggle-group
	Value: none | [ <<custom-ident>> self? ]#
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: as specified
	Animatable: no
	</pre>

	By default, each [=toggle's=] [=toggle/value=] is independent;
	incrementing one has no effect an any other.
	The 'toggle-group' property allows elements to link their [=toggles=] together:
	all [=toggles=] with the same [=toggle/name=] as the [=toggle group=]
	that are on elements [=toggle/in scope=] for the [=toggle group=]
	are linked,
	such that only one can be in an [=active value=] at a time,
	similar to HTML's <code>&lt;input type=radio></code> element.

	<dl dfn-type=value dfn-for=toggle-group>
		<dt><dfn>none</dfn>
		<dd>
			The element does not define a [=toggle group=].

		<dt><dfn lt="<custom-ident> | self">[<<custom-ident>> self?]#</dfn>
		<dd>
			The element defines one or more [=toggle groups=],
			one per comma-separated item:

			* The <<custom-ident>>
				specifies the [=toggle group/name=],
				as the item's value.
				The <<custom-ident>> cannot be the keyword <css>none</css>.

			* The ''toggle-group/self'' keyword, if specified,
				sets the [=toggle group/scope=] enum to "narrow".
				If omitted, it's set to "wide".

			Only one [=toggle=] [=in a toggle group=] can be in an [=active value=] at a time;
			see 'toggle-trigger' for details.
	</dl>

	<div class='example'>
		For example, 'toggle-group' can be used to control a tabbed display,
		so that only one panel is displayed at a time:

		<xmp class=lang-html>
			<panel-set>
				<panel-tab>first tab</panel-tab>
				<panel-card>first panel</panel-card>
				<panel-tab>second tab</panel-tab>
				<panel-card>second card</panel-card>
				...
			</panel-set>
			<style>
			panel-set {
				/* The common ancestor sets up a group */
				toggle-group: tab;
			}
			panel-tab {
				/* Each tab creates a cycle-on toggle
					(so once it's open, clicking again won't close it),
					opts into the group,
					and declares itself a toggle activator */
				toggle: tab 1 group cycle-on;
			}
			panel-tab:first-of-type {
				/* The first tab also sets its initial value
					to be active */
				toggle: tab 1 at 1 group cycle-on;
			}
			panel-tab:toggle(tab) {
				/* styling for the active tab */
			}
			panel-card {
				/* cards are hidden by default */
				display: none;
			}
			panel-card:toggle(tab) {
				display: block;
			}
			</style>
		</xmp>

		Clicking on any tab will increment its corresponding [=toggle's=] [=toggle/value=] from 0 to 1
		(and the ''cycle-on'' keyword will keep it at 1 if activated multiple times),
		while resetting the rest of the tabs' [=toggle/values=] to 0.
		Each panel is [=in scope=] for the [=toggle=] defined by its preceding tab,
		so it can respond to the [=toggle/value=] as well.
	</div>

	<div class=issue>
		Radio buttons have one particular tabbing/switching/activation behavior
		(they occupy a single tabindex spot;
		once reached you can move between them with arrow keys;
		moving to one auto-activates it),
		but not all groups will want that behavior.
		Accordions, in particular, probably don't,
		and instead just want to effectively be independent checkboxes
		that happen to only have one active at a time.

		We probably want to add a bool to toggle groups dictating this;
		are there more than these two behaviors to deal with?
	</div>


<!--
████████ ████████  ████  ██████    ██████   ████████ ████████
   ██    ██     ██  ██  ██    ██  ██    ██  ██       ██     ██
   ██    ██     ██  ██  ██        ██        ██       ██     ██
   ██    ████████   ██  ██   ████ ██   ████ ██████   ████████
   ██    ██   ██    ██  ██    ██  ██    ██  ██       ██   ██
   ██    ██    ██   ██  ██    ██  ██    ██  ██       ██    ██
   ██    ██     ██ ████  ██████    ██████   ████████ ██     ██
-->

<h3 id='toggle-trigger-property'>
Activating a Toggle: the 'toggle-trigger' property</h3>

	<pre class='propdef'>
	Name: toggle-trigger
	Value: none | <<toggle-trigger>>#
	Initial: none
	Applies to: elements without existing activation behavior (see prose)
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: the keyword ''toggle-trigger/none'', or a list of <<toggle-trigger>> values
	Animatable: no
	</pre>

	<pre class=prod>
		<dfn><<toggle-trigger>></dfn> = <<custom-ident>> <<trigger-action>>?
		<dfn><<trigger-action>></dfn> =
			[prev | next] <<integer [1, ∞]>>? |
			set <<toggle-value>>
	</pre>

	The 'toggle-trigger' property specifies that an element can be activated
	to change the value of one or more [=toggles=].
	It has the following values:

	ISSUE: Consider adding support for an at-rule that defines machine states,
	the available events to trigger from each state,
	and the resulting state of each event.
	In that case <<trigger-action>> would need to also accept custom events,
	possibly marked by a new keyword or function.

	<dl dfn-type=value dfn-for=toggle-trigger>
		: <dfn>none</dfn>
		::
			The element does not manipulate any [=toggles=].

		: <<toggle-trigger>>
		::
			If the <<trigger-action>> is omitted,
			it defaults to ''next 1''.
			If the <<trigger-action>> specifies ''prev'' or ''next'',
			but omits the following <<integer>>,
			it defaults to ''1''.

			If the element already has existing activation behavior from the host language,
			this value does nothing.

			Otherwise, the element becomes activatable,
			and when activated,
			for each comma-separated entry in the list,
			[=fires a toggle activation=]
			with the given <<custom-ident>> as a [=toggle activation/name=],
			and the <<trigger-action>> [=toggle activation/action=].

			The <<custom-ident>> cannot be the keyword <css>none</css>.
	</dl>

	A <dfn for=CSS export>toggle activation</dfn> is a struct with the following items:

	<dl dfn-for="toggle activation" export>
		: <dfn>name</dfn>
		:: The [=toggle/name=] of the [=toggle=]
			this is intended to activate.

		: <dfn>action</dfn>
		:: A <<trigger-action>> value.
	</dl>

	<div algorithm>
		To <dfn local-lt=fire export>fire a toggle activation</dfn>
		on an element |initial element|
		with a [=toggle activation=] |activation|:

		1. Let |el| initially be |initial element|.

		2. If |el| has a [=toggle=]
			with the same [=toggle/name=] as |activation|,
			and |initial element| is [=in scope=] for the [=toggle=],
			proceed to the next step.
			Otherwise, continue searching for a [=toggle=]:

			* If |el| has a [=previous sibling=],
				set |el| to that element
				and return to step 2.
			* Otherwise, if |el| has a [=parent=] element,
				set |el| to that element
				and return to step 2.
			* Otherwise, return. (No toggle was found, so nothing happens.)

		3. Let |t| be the [=toggle=] on |el|
			with the same [=toggle/name=] as |activation|.

			Let |tSpec| be the [=toggle specifier=] on |el|
			with the same [=toggle specifier/name=] as |activation|,
			if one exists.

			[=Change a toggle=] |t|,
			passing |activation|'s [=toggle activation/action=],
			and an <var ignore>override spec</var> of |tSpec|
			if it exists.

		4. [=Fire a toggle change event=] at |el| for the toggle |t|.
	</div>

	<div algorithm>
		To <dfn>change a toggle</dfn> |t|,
		given an [=toggle activation/action=] |action|,
		and optionally a [=toggle specifier=] |override spec|:

		1. If |override spec| was passed,
			let |states|, |group|, and |overflow|
			be the correspondingly-named items from |override spec|.

			Otherwise, let |states|, |group|, and |overflow|
			be the correspondingly-named items from |t|.

		2. If |action| starts with the keyword ''set'',
			then change |t|'s value
			to the value specified by |action|.

			If |t| does not [=match values|match=] 0,
			given |states|,
			and |group| is true,
			then set the [=toggle/value=] of all other [=toggles=]
			[=in a toggle group|in the same toggle group=] as |t|
			to 0.

			Return.

		3. If |t|'s [=toggle/value=] is an integer,
			let |index| be that integer.
			Otherwise, if |states| is a list of idents
			and |t|'s [=toggle/value=] is in the list,
			let |index| be the index of the first occurence of the value.
			Otherwise, let |index| be infinity.

		4. If |states| is an integer,
			let |max index| be that integer.
			Otherwise, let |max index|
			be one less than the length of |states|.

		5. If |action| starts with the keyword ''next'',
			then increment |index| by |action|'s value.
			Then, based on the value of |overflow|:

			<dl class=switch>
				: ''cycle''
				:: If |index| is greater than |maximum index|,
					set |index| to 0.

				: ''cycle-on''
				:: If |index| is greater than |maximum index|,
					set |index| to 1.

				: ''sticky''
				:: If |index| is greater than |maximum index|,
					set |index| to |maximum index|.
			</dl>

		 	Otherwise, if |action| starts with the keyword ''prev'',
			then decrement |index| by |action|'s value.
			Then, based on the value of |overflow|:

			<dl class=switch>
				: ''cycle''
				:: If |index| is less than 0
					or greater than |maximum index|,
					set |index| to |maximum index|.

				: ''cycle-on''
				:: If |index| is less than 1
					or greater than |maximum index|,
					set |index| to |maximum index|.

				: ''sticky''
				:: If |index| is less than 0,
					set |index| to 0.

					If |index| is greater than |maximum index|,
					set |index| to |maximum index|.
			</dl>

		6. If |states| is a list of idents,
			and |index| is the index of one of the entries in that list,
			set |t|'s [=toggle/value=] to that entry.

			Otherwise, set [=toggle/value=] to |index|.

		7. If |t| does not [=match values|match=] 0,
			given |states|,
			and |group| is true,
			then set the [=toggle/value=] of all other [=toggles=]
			[=in a toggle group|in the same toggle group=] as |t|
			to 0.
	</div>

	Issue: Define in much greater precision what it means to "become activatable".
	The element must become focusable
	(with a default spot in the focus order)
	and become capable of being activated by mouse/keyboard/etc.
	Similarly define the "already activatable" prose in more detail;
	we want to exclude things like text inputs,
	which would confuse a11y tooling,
	but include buttons that aren't, like, submit buttons.


<!--
 ██████  ██     ██  ███████  ████████  ████████ ██     ██    ███    ██    ██ ████████
██    ██ ██     ██ ██     ██ ██     ██    ██    ██     ██   ██ ██   ███   ██ ██     ██
██       ██     ██ ██     ██ ██     ██    ██    ██     ██  ██   ██  ████  ██ ██     ██
 ██████  █████████ ██     ██ ████████     ██    █████████ ██     ██ ██ ██ ██ ██     ██
      ██ ██     ██ ██     ██ ██   ██      ██    ██     ██ █████████ ██  ████ ██     ██
██    ██ ██     ██ ██     ██ ██    ██     ██    ██     ██ ██     ██ ██   ███ ██     ██
 ██████  ██     ██  ███████  ██     ██    ██    ██     ██ ██     ██ ██    ██ ████████
-->

<h3 id='toggle-property'>
Creating and Activating Toggles Simultaneously: the 'toggle' shorthand</h3>

	<pre class="propdef shorthand">
	Name: toggle
	Value: <<'toggle-root'>>
	</pre>

	While some cases require setting up a [=toggle=] on an ancestor
	of the elements that will activate and respond to the toggle,
	in many cases the [=toggle/scope=] rules for [=toggles=]
	are such that it's fine to create the [=toggle=]
	on the element intended to activate the toggle as well.

	The 'toggle' shorthand sets both the 'toggle-root' and 'toggle-trigger' properties on an element together.
	The entire value of the property is assigned to 'toggle-root',
	while 'toggle-trigger' is assigned to just the <<custom-ident>>s specified in the list,
	if any.

	<div class=example>
		For example,
		in the following code for an <{spoiler-text}> element,
		the show/hide button precedes the content it will show and hide,
		so we can just create the toggle on it as well:

		<xmp class=lang-html>
			<spoiler-text>
				<summary>...</summary>
				<content>...</content>
			</spoiler-text>
			<style>
				spoiler-text > summary {
					toggle: show;
				}
				spoiler-text > content {
					toggle-visibility: toggle show;
				}
			</style>
		</xmp>
	</div>

<h3 id='a11y'>
Accessibility Implications of Toggles</h3>

	<div class=issue>
		TODO

		* a 'toggle-trigger' element needs to become activatable/focusable/etc,
			and communicate in the a11y tree that it's a checkbox/radio/etc
		* we can infer what type of control it is
			by examining the properties of the toggle:
			if it's part of a group, cycle-on, etc.
		* if 'toggle-visibility' is in use,
			we can also automatically infer all the tab-set ARIA roles
	</div>


<!--
 ██  ████████  ███████   ██████    ██████   ██       ████████   ███ ███
████    ██    ██     ██ ██    ██  ██    ██  ██       ██        ██     ██
 ██     ██    ██     ██ ██        ██        ██       ██       ██       ██
        ██    ██     ██ ██   ████ ██   ████ ██       ██████   ██       ██
 ██     ██    ██     ██ ██    ██  ██    ██  ██       ██       ██       ██
████    ██    ██     ██ ██    ██  ██    ██  ██       ██        ██     ██
 ██     ██     ███████   ██████    ██████   ████████ ████████   ███ ███
-->

<h2 id='checked-pseudoclass'>
Selecting Elements Based on Toggle Value: the '':toggle()'' pseudo-class</h2>

	[[SELECTORS-4]] defines the '':checked'' pseudo-class,
	which allows author to match certain elements
	(as defined by the host language)
	depending on their "checked" state.

	[=Toggles=] provides a very similar functionality,
	allowing elements to be selected based on their [=toggle=] [=toggle/value=],
	the <dfn>:toggle()</dfn> pseudo-class:

	<pre class=prod>
		:toggle( <<custom-ident>> <<toggle-value>>? )
	</pre>

	An element matches '':toggle()''
	if the element is [=in scope=] for a [=toggle=]
	with the [=toggle/name=] given by <<custom-ident>>,
	and either the [=toggle=]
	[=match values|matches=] the provided <<toggle-value>>,
	or the <<toggle-value>> is omitted
	and the [=toggle=] is in any [=active value=].

	<div class=example>
		For example, if a [=toggle=] named "used"
		is defined on each element in an recipe's ingredient list,
		the ingredients can respond to being clicked on easily:

		<pre class=lang-css>
			.ingredient {
				toggle: used;
			}
			.ingredient:toggle(used) {
				color: silver;
				text-decoration: line-through;
			}
		</pre>
	</div>

	<div class=example>
		A checkbox that can represent an "indeterminate" value
		might have two active values.

		<pre class=lang-css>
			.tristate-check {
				toggle: check 2 at 0;
			}
			.tristate-check:toggle(check 1) {
				/* "checked" styles */
			}
			.tristate-check:toggle(check 2) {
				/* "indeterminate" styles */
			}
		</pre>
	</div>

	<div class=example>
		While '':not(:toggle(foo))'' will correctly match an element
		whose "foo" toggle is in an [=inactive value=],
		it will <em>also</em> match any element
		that doesn't see a "foo" toggle at all.

		If this is inconvenient,
		only elements that actually know about a particular toggle
		can be targeted by specifying the [=inactive value=] specifically:

		<pre class=lang-css>
			.card:toggle(show 0) {
				/* Definitely *not* shown */
			}
		</pre>
	</div>


<!--
██     ██ ████  ██████  ████ ████████  ████ ██       ████ ████████ ██    ██
██     ██  ██  ██    ██  ██  ██     ██  ██  ██        ██     ██     ██  ██
██     ██  ██  ██        ██  ██     ██  ██  ██        ██     ██      ████
██     ██  ██   ██████   ██  ████████   ██  ██        ██     ██       ██
 ██   ██   ██        ██  ██  ██     ██  ██  ██        ██     ██       ██
  ██ ██    ██  ██    ██  ██  ██     ██  ██  ██        ██     ██       ██
   ███    ████  ██████  ████ ████████  ████ ████████ ████    ██       ██
-->

<h2 id='toggle-visibility-property'>
Automatically Hiding With A Toggle</h2>

	The 'content-visibility' property
	allows an element to suppress the layout and rendering of its contents,
	similar to ''display: none'';
	however, its ''content-visibility/auto'' value allows the contents
	to still be visible to various searching and accessibility features,
	like find-in-page,
	hash-navigation,
	or tab order,
	and then to automatically become visible
	when the element becomes [=relevant to the user=].

	A common use-case for [=toggles=] is also to control whether an element is shown or hidden,
	and in many cases it would also be useful to allow the contents of elements "hidden" in this way
	to be accessible in the same ways.
	To allow for this,
	the 'toggle-visibility' property allows an element
	to both respond to and control a toggle
	with its visibility.

	<pre class="propdef">
	Name: toggle-visibility
	Value: normal | toggle <<custom-ident>>
	Initial: normal
	Inherited: no
	Applies to: all elements
	Computed value: as specified
	Animation type: not animatable
	</pre>

	The 'toggle-visibility' property
	allows an element to automatically tie its display to a particular [=toggle=] bi-directionally,
	while still exposing its contents to be focused, found-in-page, etc.,
	automatically showing itself when relevant.

	<dl dfn-type=value dfn-for=toggle-visibility>
		: <dfn>normal</dfn>
		::
			The property has no effect.

		: <dfn lt="toggle">toggle <<custom-ident>></dfn>
		::
			If the element is [=in scope=]
			for a [=toggle=] whose name matches the <<custom-ident>>,
			and that [=toggle=] is in the [=inactive value=],
			then the element acts as if ''content-visiblity: auto'' is specified,
			except that being on-screen does not make it [=relevant to the user=].

			If the element starts being [=relevant to the user=],
			it [=fires=] a [=toggle activation=],
			with a [=toggle activation/name=] of the given <<custom-ident>>
			and a [=toggle activation/action=] of ''set 1''.

			Note: If the [=toggle=] is in an [=active value=],
			or the element can't see the specified [=toggle=] at all,
			the element renders normally.
	</dl>

	<div class=example>
		For example, an "accordion" display,
		such as used for a page of FAQs,
		can use 'toggle-visibility' to hide the answers by default,
		but still make them accessible to find-in-page:

		<xmp class=lang-html>
			<dl class=accordion>
				<dt>Question 1?
				<dd>Long answer......
				<dt>Question 2?
				<dd>Another long answer.....
			</dl>
			<style>
				.accordion > dt {
					toggle: show;
				}
				.accordion > dd {
					toggle-visibility: toggle show;
				}
			</style>
		</xmp>

		Each <{dt}> establishes a separate "show" [=toggle=],
		with all the defaults filling in to produce a standard "checkbox"-like behavior,
		all initially in the [=inactive value=].
		Each <{dt}> can be activated to show or hide the following answer.

		Each <{dd}> can see the [=toggle=] established by its preceding <{dt}>,
		and will start out not rendering.
		If the user searches on the page for a term,
		or visits the page from a link with an #anchor linking into one of the answers,
		the relevant answer will automatically activate the [=toggle=],
		causing the <{dd}> to become visible.
	</div>

	Issue: Define ordering of activations,
	so if multiple elements become relevant at the same time
	and they're all part of a [=toggle group=],
	which one "wins" is well-defined.



<!--
   ███    ████████  ████
  ██ ██   ██     ██  ██
 ██   ██  ██     ██  ██
██     ██ ████████   ██
█████████ ██         ██
██     ██ ██         ██
██     ██ ██        ████
-->

<h2 id=dom>
Scripting API</h2>

<h3 id='csstogglemap' dfn-type=interface lt="CSSToggleMap">
{{CSSToggleMap}}</h3>

	<xmp class=idl>
	partial interface Element {
		[SameObject] readonly attribute CSSToggleMap toggles;
	};

	interface CSSToggleMap {
		maplike<DOMString, CSSToggle>;
		CSSToggleMap set(DOMString key, CSSToggle value);
	};
	</xmp>

	The {{Element/toggles}} attribute on {{Element}}s
	represents the [=established toggles=] on the element:
	each [=toggle=] is represented by an [=map/entry=] in the map,
	with its key equal to its [=toggle/name=]
	and its value a {{CSSToggle}} representing the rest of the [=toggle's=] data.

	Entries can be automatically added to {{Element/toggles}}
	by the 'toggle-root' property
	when [=update the rendering=] occurs,
	if 'toggle-root' defines a [=toggle specifier=]
	whose name doesn't exist in {{Element/toggles}} yet;
	see [[#toggle-creation]] for details.

	<div algorithm="CSSToggleMap.set()">
		The <dfn method for=CSSToggleMap>set(|key|, |value|)</dfn>
		[=method steps=] are:

		1. If |key| is an [=ASCII case-insensitive=] match for "none",
			[=throw=] a {{SyntaxError}}.

		2. If |value|'s {{[[ToggleMap]]}} internal slot is non-{{undefined}},
			then let |oldMap| be the [=map entries=] of the slot's value,
			and [=map/remove=] the entry from |oldMap| whose value is |value|.

		3. Set |value|'s {{[[ToggleMap]]}} internal slot to [=this=].

		4. Let |map| be [=this's=] [=map entries=]. Set |map|[|key|] to |value|.

		5. Return [=this=].

		Note: A given {{CSSToggle}} can only live in one {{CSSToggleMap}} at a time.
		This avoids some otherwise confusing or ambiguous situations.
	</div>

<h3 id=csstoggle dfn-type=interface lt="CSSToggle">
{{CSSToggle}}</h3>

	<xmp class=idl>
	interface CSSToggle {
		attribute (unsigned long or DOMString) value;
		attribute unsigned long? valueAsNumber;
		attribute DOMString? valueAsString;

		attribute (unsigned long or FrozenArray<DOMString>) states;
		attribute boolean group;
		attribute CSSToggleScope scope;
		attribute CSSToggleCycle cycle;

		constructor(optional CSSToggleData options);
	};

	dictionary CSSToggleData {
		(unsigned long or DOMString) value = 0;
		(unsigned long or sequence<DOMString>) states = 1;
		boolean group = false;
		CSSToggleScope scope = "wide";
		CSSToggleCycle cycle = "cycle";
	};

	enum CSSToggleScope {
		"narrow",
		"wide",
	};

	enum CSSToggleCycle {
		"cycle",
		"cycle-on",
		"sticky",
	};
	</xmp>

	A {{CSSToggle}} represents a [=toggle=];
	changing any attribute on the {{CSSToggle}}
	will change the corresponding items of the [=toggle=] it represents,
	and vice versa.

	Note: Only the [=toggle/value=] will change directly on a [=toggle=]
	and get reflected back to the {{CSSToggle}};
	the rest of its items are fixed on creation
	unless manually changed on its associated {{CSSToggle}}.

	A {{CSSToggle}} will usually be an [=established toggle=] on an element,
	present in the element's {{Element/toggles}} attribute,
	but can also be used independently.
	This is tracked by a <dfn attribute for=CSSToggle>\[[ToggleMap]]</dfn> internal slot,
	containing either {{undefined}} (the initial value)
	or a weak reference to the {{CSSToggleMap}} the {{CSSToggle}} is in.

	<div algorithm="CSSToggle()">
		The <code>new <dfn constructor for=CSSToggle>CSSToggle(|options|)</dfn></code> [=constructor steps=] are:

		1. [=map/For each=] |name|→|value| in |options|:

			1. If |name| is <code>"states"</code>,
				|value| is a [=/list=],
				and any of the [=list/items=] of |value|
				are [=string/identical to=] each other,
				[=throw=] a {{SyntaxError}}.

			2. Set the internal slot named |name| of [=this=]
				to |value|.

		2. Return [=this=].
	</div>

	<div algorithm="CSSToggle.valueAsNumber">
		The <dfn for=CSSToggle attribute>valueAsNumber</dfn> [=getter steps=] are:

		1. If [=this's=] {{CSSToggle/value}} slot contains an integer,
			return that.

		2. If [=this's=] {{CSSToggle/value}} slot contains a string,
			[=this's=] {{CSSToggle/states}} internal slot is a list,
			and the string is present in that list,
			return the index of the first instance of that string in the list.

		3. Otherwise, return <code>null</code>.

		The {{valueAsNumber}} [=setter steps=] are:

		1. If [=the given value=] is an integer,
			[=update the value slot=] of [=this=] to [=the given value=]
			and return.

		2. Otherwise, [=throw=] a {{TypeError}} exception.

		The {{valueAsNumber}} attribute does not have a corresponding internal slot.
	</div>

	<div algorithm="CSSToggle.valueAsString">
		The <dfn attribute for=CSSToggle>valueAsString</dfn> [=getter steps=]
		are:

		1. If [=this's=] {{CSSToggle/value}} internal slot contains an string,
			return that.

		2. If [=this's=] {{CSSToggle/value}} internal slot contains an index,
			and [=this's=] {{CSSToggle/states}} internal slot is a list
			and has an entry corresponding to that index,
			return that entry.

		3. Otherwise, return <code>null</code>.

		The {{valueAsString}} [=setter steps=] are:

		1. If [=the given value=] is an string,
			[=update the value slot=] of [=this=] to [=the given value=]
			and return.

		2. Otherwise, [=throw=] a {{TypeError}} exception.

		The {{valueAsString}} attribute does not have a corresponding internal slot.
	</div>

	<div algorithm="CSSToggle.value">
		The <dfn attribute for=CSSToggle>value</dfn> [=setter steps=]
		are to [=update the value slot=] of [=this=] to [=the given value=].
	</div>

	<div algorithm>
		To <dfn>update the value slot</dfn>
		of a {{CSSToggle}} [=this=]
		to a new value |val|:

		1. If [=this=] is an [=established toggle=],
			then [=change a toggle=] [=this=],
			with an [=toggle activation/action=]
			of ''set'' followed by |val|.

			Note: Due to the reflection,
			this will automatically update
			the {{CSSToggle/value}} internal slot of [=this=] as well.

		2. Otherwise,
			set the {{CSSToggle/value}} internal slot of [=this=]
			to |val|.
	</div>

	<div algorithm="CSSToggleValue.states">
		The <dfn attribute for=CSSToggleValue>states</dfn> [=setter steps=] are:

		1. If [=the given value=] is a sequence of {{DOMString}}s,
			and any of the sequence's items are [=identical to=] each other,
			[=throw=] a {{SyntaxError}}.

		2. Set [=this's=] {{CSSToggle/states}} internal slot to [=the given value=].
	</div>

<h3 id=csstoggleevent dfn-type=interface lt="CSSToggleEvent">
{{CSSToggleEvent}}</h3>

	<xmp class=idl>
	interface CSSToggleEvent : Event {
		constructor(DOMString type, optional CSSToggleEventInit eventInitDict = {});
		readonly attribute DOMString toggleName;
		readonly attribute CSSToggle? toggle;
	};

	dictionary CSSToggleEventInit {
		DOMString toggleName = "";
		CSSToggle? toggle = null;
	};
	</xmp>

	Issue: <a href="https://github.com/whatwg/dom/issues/600">whatwg/dom#600</a>
	means apparently events don't yet work
	if their init dictionaries have required members.
	Neither of these have reasonable defaults,
	especially the toggle part,
	but oh well I guess.

	<div algorithm>
		To <dfn export>fire a toggle change event</dfn>
		at an {{Element}} |el|
		for a [=toggle=] |toggle|
		means to
		[=fire an event=] named "togglechange"
		using {{CSSToggleEvent}},
		setting {{CSSToggleEvent/toggleName}} to |toggle|'s [=toggle/name=]
		and {{CSSToggleEvent/toggle}} to the entry of |el|'s {{Element/toggles}} map
		with |toggle|'s [=toggle/name=] as the key.
	</div>