<pre class='metadata'>
Title: CSS Toggles
Group: CSSWG
Status: UD
Work Status: exploring
ED: http://tabatkins.github.io/css-toggle/
Shortname: css-toggle
Level: 1
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact
Editor: Miriam E. Suzanne, Invited Expert, http://miriamsuzanne.com/contact
Abstract: This specification defines a way to associate a toggleable state with an element which can be used in Selectors to select an element, and declarative ways to set and modify the state on the element.
Ignored Terms: spoiler-text
</pre>

<pre class=link-defaults>
spec:css-display-3; type:dfn; text:element
</pre>

<h2 id="introduction">
Introduction</h2>

	<em>This section is not normative.</em>

	Many user-interface languages define elements which can have "toggleable state",
	which can be modified by user interaction
	and responded to by the element.
	For example, in HTML, the <code>&lt;input type=checkbox></code> has a "checked" state
	which toggles between true and false when the user activates the element,
	and which is selected by the '':checked'' pseudoclass.

	These sorts of elements are extremely useful,
	to the point that authors sometimes abuse them
	to get the same functionality on <em>other</em> elements:

	<div class='example'>
		The following markup example shows how to lightly abuse HTML semantics
		to declaratively use toggleable state:

		<xmp highlight=markup>
			<ul class='ingredients'>
			  <li><label><input type=checkbox><span>1 banana</span></label>
			  <li><label><input type=checkbox><span>1 cup blueberries</span></label>
			  ...
			</ul>
			<style>
			input[type='checkbox'] {
			  display: none;
			}
			input[type='checkbox']:checked + span {
			  color: silver;
			  text-decoration: line-through;
			}
			</style>
		</xmp>

		In this markup,
		one can cross out ingredients as they're used in the recipe
		by simply clicking on them,
		without any scripting being involved.
		The <{label}> "transfers" the activation
		to the (hidden) checkboxes,
		which are then used to style the span.
	</div>

	This module generalizes this ability
	and allows it to be applied to any element via CSS,
	so authors do not have to abuse host language semantics for styling purposes.
	It defines a a way of attaching lightweight "state" to an element via CSS
	('toggle-root'),
	defining how user interactions can change that state
	('toggle-trigger'),
	and responding to that state from CSS
	('':toggle()'' pseudo-class).
	Scripting can also create, modify, and respond to this state,
	to accommodate more complicated scenarios.

	It also defines how to infer reasonable accessibility semantics
	from the toggle structure,
	making it simpler and more reliable
	to produce accessible pages
	using these sorts of basic interactivity
	without the author having to manually annotate a page
	with ARIA attributes or similar.

<h3>Terminology</h3>

	Any element can become a <dfn export>toggle root</dfn>,
	meaning it hosts one or more [=toggles=].
	Each [=toggle=] has a name,
	a value between 0 and some maximum,
	and a few other bits of metadata,
	all of which can be set via the 'toggle-root' property.
	The toggle is visible to the [=toggle root=],
	its descendants,
	and possibly its siblings and their descendants
	(if the toggle says they can);
	any element that can "see" a [=toggle=]
	can use the '':toggle()'' pseudo-class
	to select the element based on the toggle's value.

	Any element that can see a [=toggle=]
	can also <em>trigger</em> the toggle,
	changing its value when the element is "activated",
	via the 'toggle-trigger' property.
	This means you can have elements that self-trigger their own toggle,
	like checkboxes,
	but also have toggles that are visible to wide sections of a page
	and are triggered by buttons (or tabs, or headings, etc)
	inside that section,
	so multiple elements can use '':toggle()'' to respond to the toggle.

	Toggles can also be grouped together,
	so that only one of the toggles in the group
	can have a non-zero value at a time,
	like how radio buttons work in HTML.


<h2 id=toggles>
Toggle Concepts</h2>

	A <dfn for=CSS export>toggle</dfn> is a [=struct=] associated with an [=element=],
	which represents something that can be toggled on or off by user action,
	and matched with Selectors.
	Toggles have the following [=struct/items=]:

	<dl dfn-for=toggle export>
		: <dfn>name</dfn>
		:: A <<custom-ident>>.

		: <dfn>state</dfn>
		::
			A <<custom-ident>> or non-negative <<integer>>:
			either 0 (the <dfn>inactive state</dfn>)
			or a value 1 or higher (the <dfn lt="active state">active states</dfn>).
			In order to <dfn lt="match state">match states</dfn>:

			* If the [=toggle/state=] is specified as an <<integer>>,
				and there is a corresponding <<custom-ident>> at that (zero-indexed)
				position in the list of [=toggle/state names=],
				then the [=toggle/state=] will match either
				the specified <<integer>> or that <<custom-ident>>.

			* If the [=toggle/state=] is specified as a <<custom-ident>> that
				is available in the list of [=toggle/state names=],
				then the [=toggle/state=] will match either
				the specified <<custom-ident>>,
				or the (zero-indexed) <<integer>> position of that <<custom-ident>>
				in [=toggle/state names=].

			* If there are no corresponding <<integer>> and <<custom-ident>> values,
				an <<integer>> [=toggle/state=] will only match the same <<integer>>,
				and a <<custom-ident>> [=toggle/state=] will only match the same <<custom-ident>>.

		: <dfn>state names</dfn>
		::
			A [=/list=] of state names,
			each of which are <<custom-ident>>s.

		: <dfn>group</dfn>
		::
			A [=boolean=] indicating whether the [=toggle=] is part of a [=toggle group=]
			(of the same [=toggle/name=])
			or not.

		: <dfn>scope</dfn>
		::
			An enum indicating what sort of [=toggle/scope=] the [=toggle=] uses.
			It can have two values:

			* <dfn>"wide"</dfn>, indicating the toggle has [=toggle/wide scope=]
				(it's visible to the element, its descendants,
				and its following siblings and their descendants).
			* <dfn>"narrow"</dfn>, indicating the toggle has [=toggle/narrow scope=]
				(it's visible to the element and its descendants only).
	</dl>

	[=Toggles=] are persistent state on an element,
	and are not <em>directly</em> affected by any CSS properties.
	An element can have any number of [=toggles=].

	----

	A <dfn for=CSS export>toggle group</dfn> is a [=struct=] associated with an [=element=],
	which groups together toggles of the same name
	so that only one can be in an [=active state=] at a time.
	[=Toggle groups=] have the following [=struct/items=]:

	<dl dfn-for="toggle group" export>
		: <dfn>name</dfn>
		:: A <<custom-ident>>.

		: <dfn>scope</dfn>
		::
			An enum indicating what sort of [=toggle/scope=] the [=toggle group=] uses.
			It can have two values:

			* <dfn>"wide"</dfn>, indicating the toggle has [=toggle/wide scope=]
				(it's visible to the element, its descendants,
				and its following siblings and their descendants).
			* <dfn>"narrow"</dfn>, indicating the toggle has [=toggle/narrow scope=]
				(it's visible to the element and its descendants only).
	</dl>

	[=Toggle groups=] are created by the 'toggle-group' property;
	they are not persistent state on an element.
	An element can have any number of [=toggle groups=].

	A [=toggle=] is <dfn for=toggle export>in a toggle group</dfn>
	if its [=toggle/group=] boolean is true;
	if the element is [=in scope=] for a [=toggle group=]
	with the same [=toggle/name=] as the [=toggle=],
	it's in that group;
	otherwise, it's in a document-wide <dfn for=CSS export>implicit toggle group</dfn>
	with the same [=toggle/name=].

	----

	[=Toggles=] and [=toggle groups=] have a scope,
	defining what additional elements
	(beyond the element the [=toggle=]/[=toggle group=] is on)
	can see and interact with the [=toggle=]/[=toggle group=].

	If the [=toggle=] ([=toggle group=]) has <dfn for=toggle export>wide scope</dfn>,
	it's visible to the element it's defined on,
	its descendants
	its [=tree/following=] [=tree/siblings=],
	and their [=tree/descendants=].

	If the [=toggle=] ([=toggle group=]) has <dfn for=toggle export>narrow scope</dfn>,
	it's visible to the element it's defined on
	and its descendants.

	[=Toggles=] of the same [=toggle/name=] "shadow" earlier ones;
	if multiple toggles of a given [=toggle/name=] would have overlapping scopes,
	an element is only <dfn for=toggle export>in scope</dfn>
	for the [=toggle=] created by the nearest [=preceding=] element in [=tree order=].
	The same applies to [=toggle groups=].
	However, [=toggles=] and [=toggle groups=] do not interfere with each other's scopes;
	an element can "see past" a [=toggle=] to find a [=toggle group=] of the same name it's [=in scope=] for,
	and vice versa.

	----

	A <dfn for=toggle export>toggle specifier</dfn> is a [=struct=]
	associated with an element,
	defining the initial state of a [=toggle=]
	if one needs to be created on the element,
	and how to respond to a [=toggle activation=].
	It has the following [=struct/items=]:

	<dl dfn-for="toggle specifier" export>
		: <dfn>name</dfn>
		:: A <<custom-ident>> specifying the [=toggle's=] [=toggle/name=].

		: <dfn>initial state</dfn>
		:: A non-negative integer or a <<custom-ident>>
			specifying the [=toggle's=] initial [=toggle/state=] upon creation.

		: <dfn>maximum state</dfn>
		:: A positive integer
			specifying the highest [=active state=] the [=toggle=] can reach
			throught default transitions.

		: <dfn>state names</dfn>
		:: A [=/list=] of state names,
			each of which are <<custom-ident>>s,
			assigned to the [=toggle=] initially upon creation.

		: <dfn>group</dfn>
		:: A boolean,
			specifying the [=toggle's=] initial [=toggle/group=] boolean upon creation.

		: <dfn>scope</dfn>
		:: An enum (either "wide" or "narrow"),
			specifying the [=toggle's=] initial [=toggle/scope=] upon creation.

		: <dfn>overflow</dfn>
		:: An enum (either "cycle" or "cycle-on" or "sticky"),
			specifying how to react when a [=toggle activation=]
			would increment the [=toggle/state=]
			above the specified [=maximum state=],
			or decrement the state below the (overflow-defined) minimum:

			* For "cycle-on",
				incrementing beyond the [=maximum state=]
				returns the toggle to the first active state (1),
				and decrementing below 1 returns the toggle to the [=maximum state=].

			* For "cycle",
				incrementing beyond the [=maximum state=]
				returns the toggle to the inactive state (0),
				and decrementing below 0 returns the toggle to the [=maximum state=].

			* For "sticky",
				incrementing beyond the [=maximum state=] or decrementing below 0
				does not change the [=toggle/state=].

			* If the [=toggle/state=] before activation is an <<integer>>
				that is higher than the [=toggle specifier/maximum state=],
				or a <<custom-ident>> that is not in the list of [=toggle specifier/state names=],
				then incrementing follows the specified overflow behavior,
				and decrementing returns the toggle to the [=maximum state=].
	</dl>

	[=Toggle specifiers=] are created by the 'toggle-root' property;
	they are not persistent state on an element.
	An element can have any number of [=toggle specifiers=].

	<div algorithm>
		A <dfn export>default toggle specifier</dfn> for a given |name|
		is a [=toggle specifier=]
		with a [=toggle specifier/name=] of |name|,
		an [=toggle specifier/initial state=] of 0,
		a [=toggle specifier/state names=] of an empty [=/list=],
		a false [=toggle specifier/group=],
		a [=toggle specifier/scope=] of "wide",
		a [=toggle specifier/maximum state=] of 1,
		and a [=toggle specifier/overflow=] of "cycle".

		Note: This produces behavior similar to a checkbox.
	</div>


<h3 id="toggle-vs-props">
Toggles and CSS Properties</h3>

	To allow for toggles to be responded to by Selectors
	without causing any circularity issues,
	[=toggles=] themselves are invisible state on an element,
	separate from any CSS properties that might apply.
	The CSS properties merely define which elements can <em>activate</em> a toggle,
	and which elements can <em>respond</em> to a toggle activation
	(and how they do so).

	<div class=example>
		For example, while an element needs 'toggle-root' to establish a toggle,
		once a toggle is created,
		removing the 'toggle-root' property does not affect the toggle.

		<pre class=lang-css>
		.toggleable {
			toggle-root: foo 1;
			toggle-trigger: foo;
		}
		.toggleable:toggle(foo) {
			toggle-root: none;
			toggle-trigger: none;
		}
		</pre>

		In this example, the toggleable element declares that it can establish a ''foo'' toggle,
		and activate it.
		During a rendering update,
		the ''foo'' toggle is created on the element
		(initially with a value of 0, its [=inactive state=]);
		when the element is clicked, it's incremented to its [=active state=] (1).

		At this point, the '':toggle(foo)'' rule begins to match,
		and removes the ''toggle-*'' properties.
		This does not remove the ''foo'' toggle or affect its value, however;
		it still exists and is still set to ''1'',
		so the '':toggle()'' pseudo-class will continue matching.
		However, further activations of the element
		will no longer affect the ''foo'' toggle,
		since 'toggle-trigger' was changed to ''toggle-trigger/none''.

		The ''foo'' toggle is thus "frozen" in the activated state
		(unless the author has other elements in the toggle's [=toggle/scope=] that can also affect it,
		or tweaks the value manually via JS).
	</div>


<!--
████████   ███████   ███████  ████████
██     ██ ██     ██ ██     ██    ██
██     ██ ██     ██ ██     ██    ██
████████  ██     ██ ██     ██    ██
██   ██   ██     ██ ██     ██    ██
██    ██  ██     ██ ██     ██    ██
██     ██  ███████   ███████     ██
-->

<h2 id=toggle-root-property>
Creating a Toggle: the 'toggle-root' property</h2>

	<pre class='propdef'>
	Name: toggle-root
	Value: none | <<toggle-specifier>>#
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: as specified
	Animatable: no
	</pre>

	<pre class=prod>
		<dfn><<toggle-specifier>></dfn> =
			<<custom-ident>>
			[
				<<toggle-states>> [at <<toggle-state>>]? ||
				<<toggle-overflow>> ||
				group ||
				self
			]?
		<dfn><<toggle-states>></dfn> = <<integer [1, ∞]>> | '[' <<custom-ident>>* ']'
		<dfn><<toggle-state>></dfn> = <<integer [0, ∞]>> | <<custom-ident>>
		<dfn><<toggle-overflow>></dfn> = cycle | cycle-on | sticky
	</pre>

	The 'toggle-root' property causes [=toggles=] to be created on an element,
	and controls how the [=toggles=] are updated when they are activated.

	<dl dfn-type=value dfn-for=toggle-root>
		<dt><dfn>none</dfn>
		<dd>
			The element has no [=toggle specifiers=].

			(This does not remove any [=toggles=] that have already been established
			on the element.)

		<dt><dfn><<toggle-specifier>>#</dfn>
		<dd>
			The element has one or more [=toggle specifiers=],
			one per <<toggle-specifier>>,
			which determine how toggles will be initially created,
			and how they react to being activated.

			Each <<toggle-specifier>> is composed of several parts,
			most of which are optional,
			corresponding to the [=struct/items=] of a [=toggle specifier=]:

			* The initial <<custom-ident>>
				specifies the [=toggle specifier/name=],
				as the item's value.

			* The <<toggle-states>>, if specified as an <<integer>>,
				specifies the [=toggle specifier/maximum state=].
				If specified as a bracketed list of <<custom-ident>>s,
				specifies the [=toggle specifier/state names=],
				and sets the [=toggle specifier/maximum state=]
				to the length of the list minus 1.
				If omitted, the [=toggle specifier/maximum state=] is set to 1.

			* The <<toggle-state>>, if specified,
				specifies the [=toggle specifier/initial state=].
				If omitted, it's set to 0.

			* The <<toggle-overflow>> keyword, if specified,
				specifies the [=toggle specifier/overflow=] enum.
				If omitted, it's set to "cycle".

			* The <dfn>group</dfn> keyword, if specified,
				sets the [=toggle specifier/group=] boolean to true.
				If omitted, it's set to false.

			* The <dfn>self</dfn> keyword, if specified,
				sets the [=toggle specifier/scope=] enum to "narrow".
				If omitted, it's set to "wide".
	</dl>

	<div class='example'>
		Revisiting the example in the Introduction,
		the same ingredient list can be specified in simple HTML and CSS:

		<xmp class=lang-html>
			<ul class='ingredients'>
			 	<li>1 banana
			 	<li>1 cup blueberries
				...
			</ul>
			<style>
			li {
				toggle: check self;
			}
			li:toggle(check) {
				color: silver;
				text-decoration: line-through;
			}
			</style>
		</xmp>

		The effect is identical to what was specified in the Introduction example,
		except the markup is much simpler and more semantic.
	</div>

<h3 id='toggle-creation'>
Toggle Creation Details</h3>

	Each [=element=] has a list of <dfn export for=element>established toggles</dfn>,
	representing [=toggles=] that are active on the element.
	These are created automatically by the 'toggle-root' property,
	and/or manually by interacting with the {{Element/toggles|Element.toggles}} map.

	Issue: Define the precise point in [=update the rendering=]
	when toggles are created
	if 'toggle-root' names a toggle that doesn't exist on the element yet.


<!--
 ██████   ████████   ███████  ██     ██ ████████
██    ██  ██     ██ ██     ██ ██     ██ ██     ██
██        ██     ██ ██     ██ ██     ██ ██     ██
██   ████ ████████  ██     ██ ██     ██ ████████
██    ██  ██   ██   ██     ██ ██     ██ ██
██    ██  ██    ██  ██     ██ ██     ██ ██
 ██████   ██     ██  ███████   ███████  ██
-->

<h3 id=toggle-group-property>
Linking Toggle States: the 'toggle-group' property</h3>

	<pre class='propdef'>
	Name: toggle-group
	Value: none | [ <<custom-ident>> self? ]#
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: as specified
	Animatable: no
	</pre>

	By default, each [=toggle's=] [=toggle/state=] is independent;
	incrementing one has no effect an any other.
	The 'toggle-group' property allows elements to link their [=toggles=] together:
	all [=toggles=] with the same [=toggle/name=] as the [=toggle group=]
	that are on elements [=toggle/in scope=] for the [=toggle group=]
	are linked,
	such that only one can be in an [=active state=] at a time,
	similar to HTML's <code>&lt;input type=radio></code> element.

	<dl dfn-type=value dfn-for=toggle-group>
		<dt><dfn>none</dfn>
		<dd>
			The element does not define a [=toggle group=].

		<dt><dfn lt="<custom-ident> | self">[<<custom-ident>> self?]#</dfn>
		<dd>
			The element defines one or more [=toggle groups=],
			one per comma-separated item:

			* The <<custom-ident>>
				specifies the [=toggle group/name=],
				as the item's value.

			* The ''toggle-group/self'' keyword, if specified,
				sets the [=toggle group/scope=] enum to "narrow".
				If omitted, it's set to "wide".

			Only one [=toggle=] [=in a toggle group=] can be in an [=active state=] at a time;
			see 'toggle-trigger' for details.
	</dl>

	<div class='example'>
		For example, 'toggle-group' can be used to control a tabbed display,
		so that only one panel is displayed at a time:

		<xmp class=lang-html>
			<panel-set>
				<panel-tab>first tab</panel-tab>
				<panel-card>first panel</panel-card>
				<panel-tab>second tab</panel-tab>
				<panel-card>second card</panel-card>
				...
			</panel-set>
			<style>
			panel-set {
				/* The common ancestor sets up a group */
				toggle-group: tab;
			}
			panel-tab {
				/* Each tab creates a cycle-on toggle
					(so once it's open, clicking again won't close it),
					opts into the group,
					and declares itself a toggle activator */
				toggle: tab 1 group cycle-on;
			}
			panel-tab:first-of-type {
				/* The first tab also sets its initial state
					to be active */
				toggle: tab 1 at 1 group cycle-on;
			}
			panel-tab:toggle(tab) {
				/* styling for the active tab */
			}
			panel-card {
				/* cards are hidden by default */
				display: none;
			}
			panel-card:toggle(tab) {
				display: block;
			}
			</style>
		</xmp>

		Clicking on any tab will increment its corresponding [=toggle's=] [=toggle/state=] from 0 to 1
		(and the ''cycle-on'' keyword will keep it at 1 if activated multiple times),
		while resetting the rest of the tabs' [=toggle/states=] to 0.
		Each panel is [=in scope=] for the [=toggle=] defined by its preceding tab,
		so it can respond to the [=toggle/state=] as well.
	</div>

	<div class=issue>
		Radio buttons have one particular tabbing/switching/activation behavior
		(they occupy a single tabindex spot;
		once reached you can move between them with arrow keys;
		moving to one auto-activates it),
		but not all groups will want that behavior.
		Accordions, in particular, probably don't,
		and instead just want to effectively be independent checkboxes
		that happen to only have one active at a time.

		We probably want to add a bool to toggle groups dictating this;
		are there more than these two behaviors to deal with?
	</div>


<!--
████████ ████████  ████  ██████    ██████   ████████ ████████
   ██    ██     ██  ██  ██    ██  ██    ██  ██       ██     ██
   ██    ██     ██  ██  ██        ██        ██       ██     ██
   ██    ████████   ██  ██   ████ ██   ████ ██████   ████████
   ██    ██   ██    ██  ██    ██  ██    ██  ██       ██   ██
   ██    ██    ██   ██  ██    ██  ██    ██  ██       ██    ██
   ██    ██     ██ ████  ██████    ██████   ████████ ██     ██
-->

<h3 id='toggle-trigger-property'>
Activating a Toggle: the 'toggle-trigger' property</h3>

	<pre class='propdef'>
	Name: toggle-trigger
	Value: none | <<toggle-trigger>>#
	Initial: none
	Applies to: elements without existing activation behavior (see prose)
	Inherited: no
	Percentages: n/a
	Media: interactive
	Computed value: as specified
	Animatable: no
	</pre>

	<pre class=prod>
		<df><<toggle-trigger>></dfn> = <<custom-ident>> <<trigger-action>>?
		<dfn><<trigger-action>></dfn> =
			[prev | next] <<integer [1, ∞]>>? |
			set <<toggle-state>>
	</pre>

	The 'toggle-trigger' property specifies that an element can be activated
	to change the state of one or more [=toggles=].
	It has the following values:

	ISSUE: Consider adding support for an at-rule that defines machine states,
	the available events to trigger from each state,
	and the resulting state of each event.
	In that case <<trigger-action>> would need to also accept custom events,
	possibly marked by a new keyword or function.

	<dl dfn-type=value dfn-for=toggle-trigger>
		: <dfn>none</dfn>
		::
			The element does not manipulate any [=toggles=].

		: <<toggle-trigger>>
		::
			If the element already has existing activation behavior from the host language,
			this value does nothing.

			Otherwise, the element becomes activatable,
			and when activated,
			for each comma-separated entry in the list,
			[=fires=] a [=toggle activation=]
			with the given <<custom-ident>> as a [=toggle activation/name=],
			and the <<trigger-action>> [=event=], if specified.
	</dl>

	A <dfn for=CSS export>toggle activation</dfn> is a struct with the following items:

	<dl dfn-for="toggle activation" export>
		: <dfn>name</dfn>
		:: The [=toggle/name=] of the [=toggle=]
			this is intended to activate.

		: <dfn>event</dfn>
		:: If unspecified, or specified as the keyword 'next',
			indicates that this activation will increment
			the [=toggle's=] current [=toggle/state=] by <<integer>> steps,
			or a single step if <<integer>> is not specified.
			If specified as the keyword 'prev',
			indicates that this activation will decrement
			the [=toggle's=] current [=toggle/state=] by <<integer>> steps,
			or a single step if <<integer>> is not specified.
			If specified with the keyword 'set' and a <<toggle-state>>,
			indicates the exact [=toggle/state=]
			that this activation will attempt to put the [=toggle=] into.
	</dl>

	<div algorithm>
		To <dfn local-lt=fire export>fire a toggle activation</dfn>
		on an element |initial element|
		with a [=toggle activation=] |activation|:

		1. Let |el| initially be |initial element|.

		2. If |el| has a [=toggle=]
			with the same [=toggle/name=] as |activation|,
			and |initial element| is [=in scope=] for the [=toggle=],
			then:

			1. Let |toggle| be the [=toggle=].

			2. If |el| has a [=toggle specifier=] with the same [=toggle specifier/name=],
				let |specifier| be it.

				Otherwise, let |specifier| be a new [=default toggle specifier=]
				for |activation|'s [=toggle activation/name=].

			3. Set |toggle|'s [=toggle/state=] to the result of
				the specified [=toggle activation/event=],
				following the specified [=toggle specifier/overflow=] behavior
				when incrementing or decrementing.

			4. If |toggle|'s [=toggle/state=] is now greater than zero
				and |toggle| is [=in a toggle group=],
				then for each <em>other</em> [=toggle=] in the same [=toggle group=],
				set their [=toggle/state=] to 0.

			5. Return from this algorithm.

		3. Otherwise,
			continue searching for a [=toggle=]:

			* If |el| has a [=previous sibling=],
				set |el| to that element
				and return to step 2.
			* Otherwise, if |el| has a [=parent=] element,
				set |el| to that element
				and return to step 2.
			* Otherwise, return. (No toggle was found, so nothing happens.)
	</div>

	Issue: Define in much greater precision what it means to "become activatable".
	The element must become focusable
	(with a default spot in the focus order)
	and become capable of being activated by mouse/keyboard/etc.
	Similarly define the "already activatable" prose in more detail;
	we want to exclude things like text inputs,
	which would confuse a11y tooling,
	but include buttons that aren't, like, submit buttons.


<!--
 ██████  ██     ██  ███████  ████████  ████████ ██     ██    ███    ██    ██ ████████
██    ██ ██     ██ ██     ██ ██     ██    ██    ██     ██   ██ ██   ███   ██ ██     ██
██       ██     ██ ██     ██ ██     ██    ██    ██     ██  ██   ██  ████  ██ ██     ██
 ██████  █████████ ██     ██ ████████     ██    █████████ ██     ██ ██ ██ ██ ██     ██
      ██ ██     ██ ██     ██ ██   ██      ██    ██     ██ █████████ ██  ████ ██     ██
██    ██ ██     ██ ██     ██ ██    ██     ██    ██     ██ ██     ██ ██   ███ ██     ██
 ██████  ██     ██  ███████  ██     ██    ██    ██     ██ ██     ██ ██    ██ ████████
-->

<h3 id='toggle-property'>
Creating and Activating Toggles Simultaneously: the 'toggle' shorthand</h3>

	<pre class="propdef shorthand">
	Name: toggle
	Value: <<'toggle-root'>>
	</pre>

	While some cases require setting up a [=toggle=] on an ancestor
	of the elements that will activate and respond to the toggle,
	in many cases the [=toggle/scope=] rules for [=toggles=]
	are such that it's fine to create the [=toggle=]
	on the element intended to activate the toggle as well.

	The 'toggle' shorthand sets both the 'toggle-root' and 'toggle-trigger' properties on an element together.
	The entire value of the property is assigned to 'toggle-root',
	while 'toggle-trigger' is assigned to just the <<custom-idents>>s specified in the list,
	if any.

	<div class=example>
		For example,
		in the following code for an <{spoiler-text}> element,
		the show/hide button precedes the content it will show and hide,
		so we can just create the toggle on it as well:

		<xmp class=lang-html>
			<spoiler-text>
				<summary>...</summary>
				<content>...</content>
			</spoiler-text>
			<style>
				spoiler-text > summary {
					toggle: show;
				}
				spoiler-text > content {
					toggle-visibility: toggle show;
				}
			</style>
		</xmp>
	</div>

<h3 id='a11y'>
Accessibility Implications of Toggles</h3>

	<div class=issue>
		TODO

		* a 'toggle-trigger' element needs to become activatable/focusable/etc,
			and communicate in the a11y tree that it's a checkbox/radio/etc
		* we can infer what type of control it is
			by examining the properties of the toggle:
			if it's part of a group, cycle-on, etc.
		* if 'toggle-visibility' is in use,
			we can also automatically infer all the tab-set ARIA roles
	</div>


<!--
 ██  ████████  ███████   ██████    ██████   ██       ████████   ███ ███
████    ██    ██     ██ ██    ██  ██    ██  ██       ██        ██     ██
 ██     ██    ██     ██ ██        ██        ██       ██       ██       ██
        ██    ██     ██ ██   ████ ██   ████ ██       ██████   ██       ██
 ██     ██    ██     ██ ██    ██  ██    ██  ██       ██       ██       ██
████    ██    ██     ██ ██    ██  ██    ██  ██       ██        ██     ██
 ██     ██     ███████   ██████    ██████   ████████ ████████   ███ ███
-->

<h2 id='checked-pseudoclass'>
Selecting Elements Based on Toggle State: the '':toggle()'' pseudo-class</h2>

	[[SELECTORS-4]] defines the '':checked'' pseudo-class,
	which allows author to match certain elements
	(as defined by the host language)
	depending on their "checked" state.

	[=Toggles=] provides a very similar functionality,
	allowing elements to be selected based on their [=toggle=] [=toggle/state=],
	the <dfn>:toggle()</dfn> pseudo-class:

	<pre class=prod>
		:toggle( <<custom-ident>> <<toggle-state>>? )
	</pre>

	An element matches '':toggle()''
	if the element is [=in scope=] for a [=toggle=]
	with the [=toggle/name=] given by <<custom-ident>>,
	and either the [=toggle's=] [=toggle/state=]
	[=toggle/match states|matches=] the provided <<toggle-state>>,
	or the <<toggle-state>> is omitted
	and the [=toggle=] is in any [=active state=].

	<div class=example>
		For example, if a [=toggle=] named "used"
		is defined on each element in an recipe's ingredient list,
		the ingredients can respond to being clicked on easily:

		<pre class=lang-css>
			.ingredient {
				toggle: used;
			}
			.ingredient:toggle(used) {
				color: silver;
				text-decoration: line-through;
			}
		</pre>
	</div>

	<div class=example>
		A checkbox that can represent an "indeterminate" value
		might have two active states.

		<pre class=lang-css>
			.tristate-check {
				toggle: check 2 at 0;
			}
			.tristate-check:toggle(check 1) {
				/* "checked" styles */
			}
			.tristate-check:toggle(check 2) {
				/* "indeterminate" styles */
			}
		</pre>
	</div>

	<div class=example>
		While '':not(:toggle(foo))'' will correctly match an element
		whose "foo" toggle is in an [=inactive state=],
		it will <em>also</em> match any element
		that doesn't see a "foo" toggle at all.

		If this is inconvenient,
		only elements that actually know about a particular toggle
		can be targeted by specifying the [=inactive state=] specifically:

		<pre class=lang-css>
			.card:toggle(show 0) {
				/* Definitely *not* shown */
			}
		</pre>
	</div>


<!--
██     ██ ████  ██████  ████ ████████  ████ ██       ████ ████████ ██    ██
██     ██  ██  ██    ██  ██  ██     ██  ██  ██        ██     ██     ██  ██
██     ██  ██  ██        ██  ██     ██  ██  ██        ██     ██      ████
██     ██  ██   ██████   ██  ████████   ██  ██        ██     ██       ██
 ██   ██   ██        ██  ██  ██     ██  ██  ██        ██     ██       ██
  ██ ██    ██  ██    ██  ██  ██     ██  ██  ██        ██     ██       ██
   ███    ████  ██████  ████ ████████  ████ ████████ ████    ██       ██
-->

<h2 id='toggle-visibility-property'>
Automatically Hiding With A Toggle</h2>

	The 'content-visibility' property
	allows an element to suppress the layout and rendering of its contents,
	similar to ''display: none'';
	however, its ''content-visibility/auto'' value allows the contents
	to still be visible to various searching and accessibility features,
	like find-in-page,
	hash-navigation,
	or tab order,
	and then to automatically become visible
	when the element becomes [=relevant to the user=].

	A common use-case for [=toggles=] is also to control whether an element is shown or hidden,
	and in many cases it would also be useful to allow the contents of elements "hidden" in this way
	to be accessible in the same ways.
	To allow for this,
	the 'toggle-visibility' property allows an element
	to both respond to and control a toggle
	with its visibility.

	<pre class="propdef">
	Name: toggle-visibility
	Value: normal | toggle <<custom-ident>>
	Initial: normal
	Inherited: no
	Applies to: all elements
	Computed value: as specified
	Animation type: not animatable
	</pre>

	The 'toggle-visibility' property
	allows an element to automatically tie its display to a particular [=toggle=] bi-directionally,
	while still exposing its contents to be focused, found-in-page, etc.,
	automatically showing itself when relevant.

	<dl dfn-type=value dfn-for=toggle-visibility>
		: <dfn>normal</dfn>
		::
			The property has no effect.

		: <dfn lt="toggle">toggle <<custom-ident>></dfn>
		::
			If the element is [=in scope=]
			for a [=toggle=] whose name matches the <<custom-ident>>,
			and that [=toggle=] is in the [=inactive state=],
			then the element acts as if ''content-visiblity: auto'' is specified,
			except that being on-screen does not make it [=relevant to the user=].

			If the element starts being [=relevant to the user=],
			it [=fires=] a [=toggle activation=],
			with a [=toggle activation/name=] of the given <<toggle-name>>
			and a [=toggle activation/event=] of ‘set 1’.

			Note: If the [=toggle=] is in an [=active state=],
			or the element can't see the specified [=toggle=] at all,
			the element renders normally.
	</dl>

	<div class=example>
		For example, an "accordion" display,
		such as used for a page of FAQs,
		can use 'toggle-visibility' to hide the answers by default,
		but still make them accessible to find-in-page:

		<xmp class=lang-html>
			<dl class=accordion>
				<dt>Question 1?
				<dd>Long answer......
				<dt>Question 2?
				<dd>Another long answer.....
			</dl>
			<style>
				.accordion > dt {
					toggle: show;
				}
				.accordion > dd {
					toggle-visibility: toggle show;
				}
			</style>
		</xmp>

		Each <{dt}> establishes a separate "show" [=toggle=],
		with all the defaults filling in to produce a standard "checkbox"-like behavior,
		all initially in the [=inactive state=].
		Each <{dt}> can be activated to show or hide the following answer.

		Each <{dd}> can see the [=toggle=] established by its preceding <{dt}>,
		and will start out not rendering.
		If the user searches on the page for a term,
		or visits the page from a link with an #anchor linking into one of the answers,
		the relevant answer will automatically activate the [=toggle=],
		causing the <{dd}> to become visible.
	</div>

	Issue: Define ordering of activations,
	so if multiple elements become relevant at the same time
	and they're all part of a [=toggle group=],
	which one "wins" is well-defined.



<!--
   ███    ████████  ████
  ██ ██   ██     ██  ██
 ██   ██  ██     ██  ██
██     ██ ████████   ██
█████████ ██         ██
██     ██ ██         ██
██     ██ ██        ████
-->

<h2 id=dom>
Scripting API</h2>

	<xmp class=idl>
	partial interface Element {
		attribute CSSToggleMap toggles;
	};

	interface CSSToggleMap {
		maplike<DOMString, CSSToggle>;

		CSSToggleMap set(DOMString name, CSSToggleData options);
	};

	interface CSSToggle {
		attribute int value;
		attribute int maximum;
		attribute bool group;
		attribute CSSToggleScope scope;
		attribute CSSToggleCycle cycle;

		constructor(CSSToggleData options);
	};

	dictionary CSSToggleData {
		int value;
		int maximum;
		bool group;
		CSSToggleScope scope;
		CSSToggleCycle cycle;
	};

	enum CSSToggleScope {
		"narrow",
		"wide",
	};

	enum CSSToggleCycle {
		"cycle",
		"cycle-on",
		"sticky",
	}
	</xmp>

	The {{Element/toggles}} attribute on {{Element}}s
	exposes the [=established toggles=] on the element:
	each [=toggle=] is represented by an [=map/entry=] in the map,
	with its key equal to its name
	and its value a {{CSSToggle}} representing the state of the [=toggle=].


